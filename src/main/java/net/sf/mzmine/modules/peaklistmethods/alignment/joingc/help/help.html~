<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
    <head>
        <title>Alignment - Join aligner GC</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="/net/sf/mzmine/desktop/impl/helpsystem/HelpStyles.css">
    </head>
    <body>
    

        <h1>Join aligner GC (or <b>Hierarchical Clustering aligner)</b></h1>

        <h2>Description</h2>

        <p>
            This method aligns detected peaks in different samples through a match score. This score is calculated
            based on the mass spectrum and retention time of each peak and ranges of tolerance stipulated in the parameters
            setup dialog.
        </p>
        
  <h3>Algorithm: Agglomerative / hierarchical clustering approaches</h3>
        
        <em>How 
  They Work</em></font><font face="Times New Roman, Times, serif"><br>
  Given a set of N items to be clustered, and an N*N distance (or similarity) 
  matrix, the basic process of hierarchical clustering (defined by <a href="https://home.deib.polimi.it/matteucc/Clustering/tutorial_html/hierarchical.html#johnson">S.C. 
  Johnson in 1967</a>) is this: </font></p>
<ol>
  <li><font align="justify" face="Times New Roman, Times, serif">Start by assigning 
    each item to a cluster, so that if you have N items, you now have N clusters, 
    each containing just one item. Let the distances (similarities) between the 
    clusters the same as the distances (similarities) between the items they contain.</font></li>
  <li><font face="Times New Roman, Times, serif">Find the closest (most similar) 
    pair of clusters and merge them into a single cluster, so that now you have 
    one cluster less.</font></li>
  <li><font face="Times New Roman, Times, serif">Compute distances (similarities) 
    between the new cluster and each of the old clusters.</font></li>
  <li><font face="Times New Roman, Times, serif">Repeat steps 2 and 3 until all 
    items are clustered into a single cluster of size N. (*)</font></li>
</ol>
<p align="justify"><font face="Times New Roman, Times, serif">Step 3 can be done 
  in different ways, which is what distinguishes <em>single-linkage</em> from 
  <em>complete-linkage</em> and <em>average-linkage</em> clustering.<br>
  In <em>single-linkage</em> clustering (also called the <em>connectedness</em> 
  or <em>minimum</em> method), we consider the distance between one cluster and 
  another cluster to be equal to the <u>shortest</u> distance from any member 
  of one cluster to any member of the other cluster. If the data consist of similarities, 
  we consider the similarity between one cluster and another cluster to be equal 
  to the <u>greatest</u> similarity from any member of one cluster to any member 
  of the other cluster.<br>
  In <em>complete-linkage</em> clustering (also called the <em>diameter</em> or 
  <em>maximum</em> method), we consider the distance between one cluster and another 
  cluster to be equal to the <u>greatest</u> distance from any member of one cluster 
  to any member of the other cluster.<br>
  In <em>average-linkage</em> clustering, we consider the distance between one 
  cluster and another cluster to be equal to the <u>average</u> distance from 
  any member of one cluster to any member of the other cluster.<br>
  A variation on average-link clustering is the UCLUS method of <a href="https://home.deib.polimi.it/matteucc/Clustering/tutorial_html/hierarchical.html#dandrade">R. 
  D'Andrade (1978)</a> which uses the <u>median</u> distance, which is much more 
  outlier-proof than the average distance.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">This kind of hierarchical 
  clustering is called <em>agglomerative</em> because it merges clusters iteratively. 
  There is also a <em>divisive</em> hierarchical clustering which does the reverse 
  by starting with all objects in one cluster and subdividing them into smaller 
  pieces. Divisive methods are not generally available, and rarely have been applied.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">(*) Of course there 
  is no point in having all the N items grouped in a single cluster but, once 
  you have got the complete hierarchical tree, if you want k clusters you just 
  have to cut the k-1 longest links.</font></p>
<p></p>

        
        <hr>
        
        <h3>>> Available linkage criterion are:</h3>
			<ul>
			<li>Single</li>
			<li>Complete</li>
			<li>Average</li>
			<li>Mean</li>
			<li>Centroid</li>
			<li>Ward</li>
			<li>Adjusted complete</li>
			<li>Neighbor Joining</li>
			</ul>
        

			<p>The linkage criterion determines the distance between sets of observations as a function of the pairwise distances between observations.</p>
			<p>Some commonly used linkage criteria between two sets of observations <i>A</i> and <i>B</i> are:</p>
			<img src="linkage-criteria.png" width="905" height="256" alt="">
			<p>where <i>d</i> is the chosen metric. Other linkage criteria include:</p>
			<ul>
			<li>The sum of all intra-cluster variance.</li>
			<li>The decrease in variance for the cluster being merged (<a href="https://en.wikipedia.org/wiki/Ward%27s_method" title="Ward's method">Ward's criterion</a>).</li>
			<li>The probability that candidate clusters spawn from the same distribution function (V-linkage).</li>
			<li>The product of in-degree and out-degree on a k-nearest-neighbour graph (graph degree linkage).</li>
			<li>The increment of some cluster descriptor (i.e., a quantity defined for measuring the quality of a cluster) after merging two clusters.</li>
			
         <h4>Linkage methods:</h4>
         <p><img src="single-complete-average-2.png" width="400" height="400" alt=""><p><br>
         <p><img src="ward-centroid-2.png" width="400" height="300" alt=""><p><br>
         
  <h3>>> Neighbor joining:</h3>
        
			<p>In bioinformatics, neighbor joining is a bottom-up (agglomerative) clustering method for the creation of phylogenetic trees, 
			created by Naruya Saitou and Masatoshi Nei in 1987. Usually used for trees based on DNA or protein sequence data, the algorithm requires 
			knowledge of the distance between each pair of taxa (e.g., species or sequences) to form the tree.</p>
         
			         
			Neighbor joining takes as input a <a href="https://en.wikipedia.org/wiki/Distance_matrix" title="Distance matrix">distance matrix</a> specifying the distance between each pair of taxa. The algorithm starts with a completely unresolved tree, whose topology corresponds to that of a <a href="https://en.wikipedia.org/wiki/Star_network" title="Star network">star network</a>, and iterates over the following steps until the tree is completely resolved and all branch lengths are known:</p>
			<ol>
			<li>Based on the current distance matrix calculate the matrix <span class="mwe-math-element"><b>Q</b> (defined below).</li>
			<li>Find the pair of distinct taxa i and j (i.e. with <b><i>i &#8800; j</i></b>) for which <b><i>Q(i,j)</i></b> has its lowest value. These taxa are joined to a newly created node, which is connected to the central node. In the figure at right, f and g are joined to the new node u.</li>
			<li>Calculate the distance from each of the <a href="https://en.wikipedia.org/wiki/Taxon" title="Taxon">taxa</a> in the pair to this new node.</li>
			<li>Calculate the distance from each of the taxa outside of this pair to the new node.</li>
			<li>Start the algorithm again, replacing the pair of joined neighbors with the new node and using the distances calculated in the previous step.</li>
			</ol>
			
<h4><span class="mw-headline" id="The_Q-matrix">The Q-matrix</span></h4>
<p>Based on a distance matrix relating the <b><i>n</i></b> taxa, calculate <b><i>Q</i></b> as follows:</p>
<img src="q-matrix.png" width="415" height="60" alt="">
<p>where <b><i>d(i,j)</i></b> is the distance between taxa <b><i>i</i></b> and <b><i>j</i></b>.
<h4>Distance from the pair members to the new node</h4>
<p>For each of the taxa in the pair being joined, use the following formula to calculate the distance to the new node:</p>
<img src="distance-from-the-pair-members.png" width="482" height="64" alt="">
<p>and:</p>
<img src="distance-from-the-pair-members-2.png" width="230" height="33" alt="">
<p>Taxa <b><i>f</i></b> and <b><i>g</i></b> are the paired taxa and <b><i>u</i></b> is the newly created node. 
The branches joining <b><i>f</i></b> and <b><i>u</i></b> and <b><i>g</i></b> and <b><i>u</i></b>, 
and their lengths, <b><i>&#8706;(f,u)</i></b> and <b><i>&#8706;(g,u)</i></b> are part of the tree which is 
gradually being created; they neither affect nor are affected by later neighbor-joining steps.
<h4>Distance of the other taxa from the new node</h4>
<p>For each taxon not considered in the previous step, we calculate the distance to the new node as follows:</p>
<p style="margin:0;">
<img src="distance-of-the-other-taxa.png" width="337" height="52" alt="">
</p><p>where <b><i>u</i></b> is the new node, <b><i>k</i></b> is the node which we want to calculate the distance to and <b><i>f</i></b> and <b><i>g</i></b> are the members of the pair just joined.</p>

<h4>Example (neighbor joining with 6 taxa):</h4>
         <img src="neightbor-joining.png" width="450" height="400" alt=""><p><br>


        <h3>>> How distance matrix between observations is obtained:</h3>

			Score computing: rt * weight VS chem sim * weight
			
			<ol>
			<li>Compute a similarity score based on chemical likelihood only</li>			
			<li>Compute a similarity score based on RT likelihood only</li>
			<li>Determine a combined weighted (=mixture) score based on a mixture of the above two scores</li>			
			</ol>
			
			Giving:<br>
			
			<h4>1. Chemical similarity measurement (chemSimScore))</h4>
			   <img src="chem-sim-3.png" width="675" height="232" alt="">
			   <br>
			<h4>2. Retention time score</h4>
				Retention time score is normalized relatively to the RT window tolerance provided by the user (<i><b>rtScore = (1.0d - rtDiff / rtMaxDiff)</b></i>)<br>
				<br>
			<h4>3. Mixture score</h4>
            The final mixture score (<i><b>score = (chemSimScore * mzWeight) + (rtScore * rtWeight)</b></i>).<br>
            <br>
            <img src="mixture-similarity-score.png" width="671" height="175" alt="">
            <br>
			
			<h4>A square matrix is generated by comparing all the scores, for all the pairs of peaks.</h4>

<hr>

  <h2>Method parameters</h2>

        <dl>
            <dt>Peak list name</dt>
            <dd>Name of the new aligned peak list</dd>
            <dt>Use original raw data file</dt>
            <dd>Chemical similarity is computed using unaltered m/z profile at given scan from the very oldest Raw Data File ancestor 
                (if it has not been removed). Unchecked: information are grabbed as usual 
                (from the data file the peak list to be merged was built from).</dd>
            <dt>m/z tolerance</dt>
            <dd>This value sets the range, in terms of m/z, for possible peaks to be
                aligned. Maximum allowed m/z difference</dd>
            <dt>Weight for m/z</dt>
            <dd>This is the assigned weight for m/z difference at the moment of match score calculation between peak rows.
                In case of perfectly matching m/z values the score receives the complete weight.</dd>
            <dt>Retention time tolerance type</dt>
            <dd>Maximum RT difference can be defined either using absolute or relative value</dd>
            <dt>Absolute RT tolerance</dt>
            <dd>Maximum allowed absolute RT difference</dd>
            <dt>Relative RT tolerance</dt>
            <dd>Maximum allowed relative RT difference</dd>
            <dt>Weight for RT</dt>
            <dd>This is the assigned weight for RT difference at the moment of match score calculation between peak rows.
                In case of perfectly matching RT values the score receives the complete weight.</dd>
                
            <dt>Use apex</dt>
            <dd>Use apex scan for RT and MZ profile. Otherwise, 5% of the scans around the apex are used to redefine averaged RT and MZ profile.</dd>
            <dt>Use RT recalibration</dt>
            <dd>Use compounds with known identities to ease alignment. See "Identification - Custom JDX(s) search" help entry.</dd>
            <dt>Use DETECTED m/z only</dt>
            <dd>Use simplified spectra resulting from a previous 'merge step' (See "Peak detection - RT based peak merger" help entry)) to compute chemical similarity score.</dd>
            
            <dt>RT tolerance post-recalibration</dt>
            <dd>Ignored if "Use RT recalibration" is unchecked. Maximum allowed difference between two RT values after RT recalibration.</dd>
            <dt>Dendrogram text format</dt>
            <dd>Ignored if "Export dendrogram as TXT" is unchecked. possible values are: <I>NEWICK</I> (standard printing), or <I>RAW</I> (flat human readable non-standard printing).</dd>
            <dt>Dendrogram output text filename</dt>
            <dd>Name of the resulting TXT file to write the clustering resulting dendrogram to. If the file already exists, it will be overwritten.</dd>

        </dl>

       <br>
       <hr align="center" width="50">
       <br>
       
        <p>
         <b>New aligned peak list showing peaks from 3 different samples</b><br>
         <br>
         <img src="alignment-result.png" width="1292" height="624" alt="">
        </p>
        
        <p>
         <b>Clustering result can be exported into RAW text or NEWICK format</b><br>
         The latter can be then browsed using common applications such as <a href="http://tree.bio.ed.ac.uk/software/figtree/" name="FigTree" title="FigTree">FigTree</a>.<br>
         <br>
         <img src="figtree.png" width="1148" height="311" alt="">
        </p>

<hr>

			<p>
			<h2>Inspiration was taken from</h2>
			<ul>
			<li><a href="Bioinformatics-2011-Kim-bioinformatics_btr188.pdf">An Optimal Peak Alignment For Comprehensive
Two-Dimensional Gas Chromatography Mass
Spectrometry Using Mixture Similarity Measure</a></li>			
			<li><a href="http://www.cs.waikato.ac.nz/ml/weka/">WEKA hierarchical clustering</a></li>			
			</ul>			
			</p>

    </body>
</html>
